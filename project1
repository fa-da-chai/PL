# include <stdio.h>
# include <string>
# include <iostream>
# include <stdlib.h>
# include <vector>
# include <stack>

using namespace std ;

int gLine = 0 ; 
int gColumn = 0 ;
int gTestNum ;

enum TokenType {
  INT, STRING, DOT, FLOAT, NIL,
  T, QUOTE, SYMBOL, LEFT_PAREN, RIGHT_PAREN 
};

struct Token {
  int tokenType ;
  string lexeme ;   
  // int line ;
  int column ;
} ; 

struct TreeNode {
  int tokenType ;
  string lexeme ;   
  // int line ;
  int column ;
  TreeNode *left ;
  TreeNode *right ;
} ; 

struct ANodeOfLine {
  int line ;
  vector<Token> tokenList ;
  ANodeOfLine *next ;
} ;

typedef ANodeOfLine *ANodeOfLinePtr ;
typedef TreeNode *TreeNodePtr ; // use to build token tree 

bool ReadSExp( ANodeOfLinePtr &programHead ) ; 
string GetToken( bool &eol ) ; // return false if doesn't get token
bool IsWhiteSpace( char ch ) ;
bool IsSeparator( char ch ) ;
void SkipWhiteSpace() ;
void SkipComment() ;
bool IsExit( vector<Token> tokenList ) ;
int DefToken( string lexeme ) ;
bool IsNum( char ch ) ;
bool IsOperator( char ch ) ; // +,-,*,/
void BuileTree( vector<Token> tokenList ) ;
void HandleBackslash( string &token ) ;
void PrintSExp( ANodeOfLinePtr head ) ;

class TokenTree {
  private :
    TreeNodePtr head ;
    stack parenthese ;
    TreeNodePtr BuildRecursive( TreeNodePtr walk, Token token ) ; 

  public :
    TreeNodePtr BuildTokenTree( vector<Token> tokenList, int index ) ;
} ;

int main() {
  bool haveExit = false ;
  ANodeOfLinePtr programHead ;
  scanf( "%d", &gTestNum ) ;
  cout << "Welcome to OurScheme!" ;
  cout << "\n\n" ;
  cout << "> " ;
  haveExit = ReadSExp( programHead ) ;
  if ( haveExit ) {
    cout << endl << "Thanks for using OurScheme!" ;
  } // if

  else {
    // error END-OF-FILE encountered
  } // else
  /*
  repeat
  
    ReadSExp(expr);
    
    PrintSExp(expr); // You must "pretty print" this data structure.
      
    Print '> '
    
  until (OR (user entered '(exit)')
            (END-OF-FILE encountered)
        )
  
  if ( END-OF-FILE encountered ) // and NOT ?user entered '(exit)'?
    Print 'ERROR (no more input) : END-OF-FILE encountered' 

  Print '\n'
  Print 'Thanks for using OurScheme!' // Doesn't matter whether there is an
                                      // '\n' at the end
  */
} // main()

bool ReadSExp( ANodeOfLinePtr &programHead ) {
  Token token ;
  programHead = new ANodeOfLine ;
  ANodeOfLinePtr walk = programHead ;
  programHead -> next = NULL ;
  bool eol = false ; // END_OF_LINE
  bool exit = false ; 

  token.lexeme = GetToken( eol ) ;
  while ( cin.peek() != EOF && !exit ) {
    token.tokenType = DefToken( token.lexeme ) ;
    walk -> tokenList.push_back( token ) ;
    if ( eol )  {
      exit = IsExit( walk -> tokenList ) ;
      // assign line to a node of line
      if ( !exit ) {
        PrintSExp( walk ) ;
        walk -> next = new ANodeOfLine ;
        walk = walk -> next ;
        walk -> next = NULL ;
        eol = false ;
      } // if
    } // if

    if ( !exit )
      token.lexeme = GetToken( eol ) ;
    // judge the token type
    // put token into tokenlist
    // build tree(pretty print)
  } // while

  return exit ;
} // ReadSExp()

string GetToken( bool &eol ) {
  char ch ;
  string token = "" ;
  bool firstIsSprt = true ;
  eol = false ;
  SkipWhiteSpace() ;
  while ( cin.peek() != EOF && !IsSeparator( cin.peek() ) ) {
    scanf( "%c", &ch ) ;
    if ( ch == ';' ) { // skip comment ;
      SkipComment() ;
    } // if

    else {
      token += ch ;
      firstIsSprt = false ;
    }  // else
  } // while

  if ( firstIsSprt ) { // white-space, (, ), ', ", ;
    scanf( "%c", &ch ) ;
    if ( ch == ';' ) { // comment
     SkipComment() ;
    } // if

    else if ( ch == '"' ) { // string
      token += ch ;
      bool endStr = false, findDoubleQuote = false ;
      while ( !endStr ) { // get string
        scanf( "%c", &ch ) ;
        if ( ch == '\"' ) {
          token += ch ;
          findDoubleQuote = true ;
          endStr = true ;
        } // if
        
        else if ( ch == '\n' ) {
          endStr = true ;
          // error:not have double quote
        } // else if

        else if ( ch == '\\' ) {
          HandleBackslash( token ) ;
        } // else if

        else {
          token += ch ;
        } // else 
      } // while

      eol = true ;
    } // else if

    else {
      token += ch ;
    } // else
  } // if

  if ( cin.peek() == '\n' ) {
    eol = true ;
  } // if

  if ( token == "t" ) {
    token = "#t" ;
  } // if
  
  else if ( token == "#f" || ( token == "(" && cin.peek() == ')' ) ) { // nil, #f
    if ( cin.peek() == '(' ) // 讀掉')'
      scanf( "%c", &ch ) ;

    token = "nil" ;
  } // else if

  return token ;
} // GetToken()

bool IsWhiteSpace( char ch ) { // ' ', '\n', '\t', end of file
  if ( ch == ' ' )
    return true ;
  else if ( ch == '\n' )
    return true ;
  else if ( ch == '\t' )
    return true ;
  else 
    return false ; 
} // IsWhiteSpace()

bool IsSeparator( char ch ) { // white space, '(', ')', '\'', '\"', ';'
  if ( IsWhiteSpace( ch ) )
    return true ;
  else if ( ch == '(' )
    return true ;
  else if ( ch == ')' )
    return true ;
  else if ( ch == '\'' )
    return true ;
  else if ( ch == '\"' )
    return true ;
  else if ( ch == ';' )
    return true ;
  else 
    return false ;
} // IsSeparator()

void SkipWhiteSpace() {
  while ( cin.peek() != EOF && IsWhiteSpace( cin.peek() ) ) {
    char ch ;
    scanf( "%c", &ch ) ;
    if ( ch == '\n' )
      gLine++ ;
  } // while
} // SkipWhiteSpace()

void SkipComment() {
  char cStr[256] ;
  if ( !cin.get( cStr, 256, '\n' ) )
    cout << "error：last line is comment\n" ;
} // SkipComment() 

bool IsExit( vector<Token> tokenList ) {
  if ( tokenList[0].lexeme == "(" ) {
    if ( tokenList[1].lexeme == "exit" ) {
      if ( tokenList[2].lexeme == ")" ) {
        return true ;
      } // if
    } // if
  } // if

  return false ;
} // IsExit()

int DefToken( string lexeme ) {
  if ( lexeme == "(" ) {
    return LEFT_PAREN ;
  } // if

  else if ( lexeme == ")" ) {
    return RIGHT_PAREN ;
  } // else if

  else if ( lexeme == "." ) {
    return DOT ;
  } // else if

  else if ( lexeme[0] == '"' ) {
    return STRING ;
  } // else if

  else if ( lexeme == "nil" || lexeme == "#f" ) {
    return NIL ;
  } // else if

  else if ( lexeme == "t" || lexeme == "#t" ) {
    return T ;
  } // else if

  else if ( lexeme == "'" || lexeme == "\"" ) {
    return QUOTE ;
  } // else if

  else if ( IsNum( lexeme[0] ) || IsOperator( lexeme[0] ) || lexeme[0] == '.' ) { // int or float
    for ( int i = 0 ; i < lexeme.size() ; i++ ) {
      if ( lexeme[i] == '.' ) {
        return FLOAT ;
      } // if
    } // for

    return INT ;
    // may have error 
  } // else if

  else { // symbol
    return SYMBOL ;
    // maybe have error 
  } // else 
} // DefToken()

bool IsNum( char ch ) {
  if ( ch >= '0' && ch <= '9' )
    return true ;

  return false ;
} // IsNum()

bool IsOperator( char ch ) { // +,-,*,/
  if ( ch == '+' ) 
    return true ;

  else if ( ch == '-' )
    return true ;

  else if ( ch == '*' )
    return true ;

  else if ( ch == '/' )
    return true ;

  else 
    return false ;
} // IsOperator()

void HandleBackslash( string &token ) {
  char ch = '\\' ;
  if ( cin.peek() == '\"' ) {
    scanf( "%c", &ch ) ;
    token += ch ;
  } // if

  else if ( cin.peek() == '\\' ) {
    scanf( "%c", &ch ) ;
    token += ch ;
  } // else if
 
  else if ( cin.peek() == 'n' ) {
    scanf( "%c", &ch ) ;
    token += '\n' ;   
  } // else if

  else if ( cin.peek() == 't' ) {
    scanf( "%c", &ch ) ;
    token += '\t' ;
  } // else if

  else {
    token += ch ;
  } // else
} // HandleBackslash()

void PrintSExp( ANodeOfLinePtr head ) {
  // BuildTree()
  for ( int i = 0 ; i < head -> tokenList.size() ; i++ ) {
    if ( head -> tokenList[i].tokenType == INT ) { // handle +123, +12.3, -5.6363
      int tempInt = stoi( head -> tokenList[i].lexeme ) ;
      cout << tempInt ;
    } // if

    else if ( head -> tokenList[i].tokenType == FLOAT ) { // +123.5,-5.6363,-9.2
      float tempFloat = stof( head -> tokenList[i].lexeme ) ; 
      printf( "%.3f", tempFloat ) ;
    } // else if

    else {
      cout << head -> tokenList[i].lexeme ;
    } // else
  } // for // --------------------------------------------------------temp print 

  cout << endl << endl ;
  cout << "> " ;
} // PrintSExp()


