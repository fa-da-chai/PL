# include <stdio.h>
# include <string>
# include <iostream>
# include <stdlib.h>
# include <vector>

using namespace std ;

int gLine = 0 ; 
int gColumn = 0 ;
int gTestNum ;

enum TokenType {
  INT, STRING, DOT, FLOAT, NIL,
  T, QUOTE, SYMBOL, LEFT_PAREN, RIGHT_PAREN 
};

struct Token {
  int tokenType ;
  string lexeme ;   
  // int line ;
  int column ;
} ; 

struct ANodeOfLine {
  int line ;
  vector<Token> tokenList ;
  ANodeOfLine *next ;
} ;

typedef ANodeOfLine *ANodeOfLinePtr ;

void ReadSExp( ANodeOfLinePtr &programHead ) ; 
string GetToken( bool &eol ) ; // return false if doesn't get token
bool IsWhiteSpace( char ch ) ;
bool IsSeparator( char ch ) ;
void SkipWhiteSpace() ;
void SkipComment() ;
bool IsExit( vector<Token> tokenList ) ;
int DefToken( string lexeme ) ;
bool IsNum( char ch ) ;
bool IsOperator( char ch ) ; // +,-,*,/

int main() {
  ANodeOfLinePtr programHead ;
  scanf( "%d", &gTestNum ) ;
  cout << "Welcome to OurScheme!" ;
  cout << "\n\n" ;
  cout << "> " ;
  ReadSExp( programHead ) ;
  /*
  repeat
  
    ReadSExp(expr);
    
    PrintSExp(expr); // You must "pretty print" this data structure.
      
    Print '> '
    
  until (OR (user entered '(exit)')
            (END-OF-FILE encountered)
        )
  
  if ( END-OF-FILE encountered ) // and NOT ?user entered '(exit)'?
    Print 'ERROR (no more input) : END-OF-FILE encountered' 

  Print '\n'
  Print 'Thanks for using OurScheme!' // Doesn't matter whether there is an
                                      // '\n' at the end
  */
} // main()

void ReadSExp( ANodeOfLinePtr &programHead ) {
  Token token ;
  programHead = new ANodeOfLine ;
  ANodeOfLinePtr walk = programHead ;
  programHead -> next = NULL ;
  bool eol = false ; // END_OF_LINE
  bool exit = false ; 

  token.lexeme = GetToken( eol ) ;
  while ( cin.peek() != EOF && !exit ) {
    token.tokenType = DefToken( token.lexeme ) ;
    walk -> tokenList.push_back( token ) ;
    if ( eol )  {
      exit = IsExit( walk -> tokenList ) ;
      // assign line to a node of line
      if ( !exit ) {
        for ( int i = 0 ; i < walk -> tokenList.size() ; i++ ) {
          cout << walk -> tokenList[i].lexeme ;
        } // for
  
        cout << endl << endl ;
        cout << "> " ;
        walk -> next = new ANodeOfLine ;
        walk = walk -> next ;
        walk -> next = NULL ;
        eol = false ;
      } // if
    } // if

    if ( !exit )
      token.lexeme = GetToken( eol ) ;
    // judge the token type
    // put token into tokenlist
    // build tree(pretty print)
  } // while
} // ReadSExp()

string GetToken( bool &eol ) {
  char ch ;
  string token = "" ;
  bool firstIsSprt = true ;
  eol = false ;
  SkipWhiteSpace() ;
  while ( cin.peek() != EOF && !IsSeparator( cin.peek() ) ) {
    scanf( "%c", &ch ) ;
    if ( ch == ';' ) { // skip comment ;
      SkipComment() ;
    } // if

    else {
      token += ch ;
      firstIsSprt = false ;
    }  // else
  } // while

  if ( firstIsSprt ) { 
    scanf( "%c", &ch ) ;
    if ( ch == ';' ) {
      char comment[256] ;
      cin.getline( comment, 256, '\n' ) ;
    } // if

    else if ( ch == '"' ) { // string
      token += ch ;
      bool endStr = false, findDoubleQuote = false ;
      while ( !endStr ) { // get string
        scanf( "%c", &ch ) ;
        if ( ch == '"' ) {
          token += ch ;
          findDoubleQuote = true ;
          endStr = true ;
        } // if
        
        else if ( ch == '\n' ) {
          endStr = true ;
          // error:not have double quote
        } // else if

        else {
          token += ch ;
        } // else 
      } // while
    } // else if

    else {
      token += ch ;
    } // else
  } // if

  if ( cin.peek() == '\n' ) {
    eol = true ;
  } // if

  return token ;
} // GetToken()

bool IsWhiteSpace( char ch ) { // ' ', '\n', '\t', end of file
  if ( ch == ' ' )
    return true ;
  else if ( ch == '\n' )
    return true ;
  else if ( ch == '\t' )
    return true ;
  else 
    return false ; 
} // IsWhiteSpace()

bool IsSeparator( char ch ) { // white space, '(', ')', '\'', '\"', ';'
  if ( IsWhiteSpace( ch ) )
    return true ;
  else if ( ch == '(' )
    return true ;
  else if ( ch == ')' )
    return true ;
  else if ( ch == '\'' )
    return true ;
  else if ( ch == '\"' )
    return true ;
  else if ( ch == ';' )
    return true ;
  else 
    return false ;
} // IsSeparator()

void SkipWhiteSpace() {
  while ( cin.peek() != EOF && IsWhiteSpace( cin.peek() ) ) {
    char ch ;
    scanf( "%c", &ch ) ;
    if ( ch == '\n' )
      gLine++ ;
  } // while
} // SkipWhiteSpace()

void SkipComment() {
  char cStr[256] ;
  if ( !cin.get( cStr, 256, '\n' ) )
    cout << "errorï¼šlast  line is comment\n" ;
} // SkipComment() 

bool IsExit( vector<Token> tokenList ) {
  if ( tokenList[0].lexeme == "(" ) {
    if ( tokenList[1].lexeme == "exit" ) {
      if ( tokenList[2].lexeme == ")" ) {
        return true ;
      } // if
    } // if
  } // if

  return false ;
} // IsExit()

int DefToken( string lexeme ) {
  if ( lexeme == "(" ) {
    return LEFT_PAREN ;
  } // if

  else if ( lexeme == ")" ) {
    return RIGHT_PAREN ;
  } // else if

  else if ( lexeme == "." ) {
    return DOT ;
  } // else if

  else if ( lexeme[0] == '"' ) {
    return STRING ;
  } // else if

  else if ( lexeme == "nil" || lexeme == "#f" ) {
    return NIL ;
  } // else if

  else if ( lexeme == "t" || lexeme == "#t" ) {
    return T ;
  } // else if

  else if ( lexeme == "'" || lexeme == "\"" ) {
    return QUOTE ;
  } // else if

  else if ( IsNum( lexeme[0] ) || IsOperator( lexeme[0] ) || lexeme[0] == '.' ) { // int or float
    for ( int i = 0 ; i < lexeme.size() ; i++ ) {
      if ( lexeme[i] == '.' ) {
        return FLOAT ;
      } // if
    } // for

    return INT ;
    // may have error 
  } // else if

  else { // symbol
    return SYMBOL ;
    // maybe have error 
  } // else 
} // DefToken()

bool IsNum( char ch ) {
  if ( ch >= '0' && ch <= '9' )
    return true ;

  return false ;
} // IsNum()

bool IsOperator( char ch ) {
  if ( ch == '+' ) 
    return true ;

  else if ( ch == '-' )
    return true ;

  else if ( ch == '*' )
    return true ;

  else if ( ch == '/' )
    return true ;

  else 
    return false ;
} // IsOperator()



