# include <stdio.h>
# include <string>
# include <iostream>
# include <stdlib.h>
# include <vector>
# include <stack>

using namespace std ;

int gLine = 0 ; 
int gColumn = 0 ;
int gTestNum ;

enum TokenType {
  INT, STRING, DOT, FLOAT, NIL,
  T, QUOTE, SYMBOL, LEFT_PAREN, RIGHT_PAREN 
};

struct Token {
  int tokenType ;
  string lexeme ;   
  // int line ;
  int column ;
} ; 

struct TokenTreeNode {
  Token token ;  
  bool internal ;
  TokenTreeNode *left ;
  TokenTreeNode *right ;
} ; 

struct ANodeOfLine {
  int line ;
  vector<Token> tokenList ;
  ANodeOfLine *next ;
} ;

typedef ANodeOfLine *ANodeOfLinePtr ;
typedef TokenTreeNode *TokenTreeNodePtr ; // use to build token tree 

bool ReadSExp( ANodeOfLinePtr &programHead ) ; 
string GetToken( bool &eol ) ; // return false if doesn't get token
bool IsWhiteSpace( char ch ) ;
bool IsSeparator( char ch ) ;
void SkipWhiteSpace() ;
void SkipComment() ;
bool IsExit( vector<Token> tokenList ) ;
int DefToken( string lexeme ) ;
bool IsNum( char ch ) ;
bool IsOperator( char ch ) ; // +,-,*,/
void BuileTree( vector<Token> tokenList ) ;
void HandleBackslash( string &token ) ;
void PrintSExp( ANodeOfLinePtr head ) ;

class TokenTree {
  private :
    TokenTreeNodePtr head ;
    int parentheseCount ;
    
  public :
    void BuildTokenTree( vector<Token> tokenList ) ;
    TokenTreeNodePtr GetTokenTree() {
      return head ;
    } // GetTokenTree()

    void Reset() {
      head = NULL ;
      parentheseCount = 0 ;
    } // Reset()
} ;

int main() {
  bool haveExit = false ;
  ANodeOfLinePtr programHead = NULL ;
  programHead -> next = NULL ;
  scanf( "%d", &gTestNum ) ;
  cout << "Welcome to OurScheme!" ;
  cout << "\n\n" ;
  cout << "> " ;
  haveExit = ReadSExp( programHead ) ;
  if ( haveExit ) {
    cout << endl << "Thanks for using OurScheme!" ;
  } // if

  else {
    // error END-OF-FILE encountered
  } // else
  /*
  repeat
  
    ReadSExp(expr);
    
    PrintSExp(expr); // You must "pretty print" this data structure.
      
    Print '> '
    
  until (OR (user entered '(exit)')
            (END-OF-FILE encountered)
        )
  
  if ( END-OF-FILE encountered ) // and NOT ?user entered '(exit)'?
    Print 'ERROR (no more input) : END-OF-FILE encountered' 

  Print '\n'
  Print 'Thanks for using OurScheme!' // Doesn't matter whether there is an
                                      // '\n' at the end
  */
} // main()

bool ReadSExp( ANodeOfLinePtr &programHead ) {
  Token token ;
  programHead = new ANodeOfLine ;
  ANodeOfLinePtr walk = programHead ;
  bool eol = false ; // END_OF_LINE
  bool exit = false ; 

  token.lexeme = GetToken( eol ) ;
  while ( cin.peek() != EOF && !exit ) {
    token.tokenType = DefToken( token.lexeme ) ;
    walk -> tokenList.push_back( token ) ;
    if ( eol )  {
      exit = IsExit( walk -> tokenList ) ;
      // assign line to a node of line
      if ( !exit ) {
        PrintSExp( walk ) ;
        walk -> next = new ANodeOfLine ;
        walk = walk -> next ;
        walk -> next = NULL ;
        eol = false ;
      } // if
    } // if

    if ( !exit )
      token.lexeme = GetToken( eol ) ;

    // build tree(pretty print)
  } // while

  return exit ;
} // ReadSExp()

string GetToken( bool &eol ) {
  char ch ;
  string token = "" ;
  bool firstIsSprt = true ;
  eol = false ;
  SkipWhiteSpace() ;
  while ( cin.peek() != EOF && !IsSeparator( cin.peek() ) ) {
    scanf( "%c", &ch ) ;
    if ( ch == ';' ) { // skip comment ;
      SkipComment() ;
    } // if

    else {
      token += ch ;
      firstIsSprt = false ;
    }  // else
  } // while

  if ( firstIsSprt ) { // white-space, (, ), ', ", ;
    scanf( "%c", &ch ) ;
    if ( ch == ';' ) { // comment
     SkipComment() ;
    } // if

    else if ( ch == '"' ) { // string
      token += ch ;
      bool endStr = false, findDoubleQuote = false ;
      while ( !endStr ) { // get string
        scanf( "%c", &ch ) ;
        if ( ch == '\"' ) {
          token += ch ;
          findDoubleQuote = true ;
          endStr = true ;
        } // if
        
        else if ( ch == '\n' ) {
          endStr = true ;
          // error:not have double quote
        } // else if

        else if ( ch == '\\' ) {
          HandleBackslash( token ) ;
        } // else if

        else {
          token += ch ;
        } // else 
      } // while

      eol = true ;
    } // else if

    else {
      token += ch ;
    } // else
  } // if

  if ( cin.peek() == '\n' ) {
    eol = true ;
  } // if

  if ( token == "t" ) {
    token = "#t" ;
  } // if
  
  else if ( token == "#f" || ( token == "(" && cin.peek() == ')' ) ) { // nil, #f
    if ( cin.peek() == '(' ) // 讀掉')'
      scanf( "%c", &ch ) ;

    token = "nil" ;
  } // else if

  return token ;
} // GetToken()

bool IsWhiteSpace( char ch ) { // ' ', '\n', '\t', end of file
  if ( ch == ' ' )
    return true ;
  else if ( ch == '\n' )
    return true ;
  else if ( ch == '\t' )
    return true ;
  else 
    return false ; 
} // IsWhiteSpace()

bool IsSeparator( char ch ) { // white space, '(', ')', '\'', '\"', ';'
  if ( IsWhiteSpace( ch ) )
    return true ;
  else if ( ch == '(' )
    return true ;
  else if ( ch == ')' )
    return true ;
  else if ( ch == '\'' )
    return true ;
  else if ( ch == '\"' )
    return true ;
  else if ( ch == ';' )
    return true ;
  else 
    return false ;
} // IsSeparator()

void SkipWhiteSpace() {
  while ( cin.peek() != EOF && IsWhiteSpace( cin.peek() ) ) {
    char ch ;
    scanf( "%c", &ch ) ;
    if ( ch == '\n' )
      gLine++ ;
  } // while
} // SkipWhiteSpace()

void SkipComment() {
  char cStr[256] ;
  if ( !cin.get( cStr, 256, '\n' ) )
    cout << "error：last line is comment\n" ;
} // SkipComment() 

bool IsExit( vector<Token> tokenList ) {
  if ( tokenList[0].lexeme == "(" ) {
    if ( tokenList[1].lexeme == "exit" ) {
      if ( tokenList[2].lexeme == ")" ) {
        return true ;
      } // if
    } // if
  } // if

  return false ;
} // IsExit()

int DefToken( string lexeme ) {
  if ( lexeme == "(" ) {
    return LEFT_PAREN ;
  } // if

  else if ( lexeme == ")" ) {
    return RIGHT_PAREN ;
  } // else if

  else if ( lexeme == "." ) {
    return DOT ;
  } // else if

  else if ( lexeme[0] == '"' ) {
    return STRING ;
  } // else if

  else if ( lexeme == "nil" || lexeme == "#f" ) {
    return NIL ;
  } // else if

  else if ( lexeme == "t" || lexeme == "#t" ) {
    return T ;
  } // else if

  else if ( lexeme == "'" || lexeme == "\"" ) {
    return QUOTE ;
  } // else if

  else if ( IsNum( lexeme[0] ) || IsOperator( lexeme[0] ) || lexeme[0] == '.' ) { // int or float
    bool isFloat = false, haveADot = false ;
    bool isSymbol = false ;
    for ( int i = 0 ; i < lexeme.size() ; i++ ) {
      if ( lexeme[i] == '.' && !haveADot ) {
        isFloat = true ;
        haveADot = true ;
      } // if

      else if ( !IsNum( lexeme[i] ) ) {
        isSymbol = true ;
      } // else if
    } // for

    if ( isSymbol )
      return SYMBOL ;
    else if ( isFloat )
      return FLOAT ;
    else 
      return INT ;
    // may have error 
  } // else if

  else { // symbol
    return SYMBOL ;
    // maybe have error 
  } // else 
} // DefToken()

bool IsNum( char ch ) {
  if ( ch >= '0' && ch <= '9' )
    return true ;

  return false ;
} // IsNum()

bool IsOperator( char ch ) { // +,-,*,/
  if ( ch == '+' ) 
    return true ;

  else if ( ch == '-' )
    return true ;

  else if ( ch == '*' )
    return true ;

  else if ( ch == '/' )
    return true ;

  else 
    return false ;
} // IsOperator()

void HandleBackslash( string &token ) {
  char ch = '\\' ;
  if ( cin.peek() == '\"' ) {
    scanf( "%c", &ch ) ;
    token += ch ;
  } // if

  else if ( cin.peek() == '\\' ) {
    scanf( "%c", &ch ) ;
    token += ch ;
  } // else if
 
  else if ( cin.peek() == 'n' ) {
    scanf( "%c", &ch ) ;
    token += '\n' ;   
  } // else if

  else if ( cin.peek() == 't' ) {
    scanf( "%c", &ch ) ;
    token += '\t' ;
  } // else if

  else {
    token += ch ;
  } // else
} // HandleBackslash()

void PrintSExp( ANodeOfLinePtr head ) {
  // BuildTree()
  for ( int i = 0 ; i < head -> tokenList.size() ; i++ ) {
    if ( head -> tokenList[i].tokenType == INT ) { // handle +123, +12.3, -5.6363
      int tempInt = stoi( head -> tokenList[i].lexeme ) ;
      cout << tempInt ;
    } // if

    else if ( head -> tokenList[i].tokenType == FLOAT ) { // +123.5,-5.6363,-9.2
      float tempFloat = stof( head -> tokenList[i].lexeme ) ; 
      printf( "%.3f", tempFloat ) ;
    } // else if

    else {
      cout << head -> tokenList[i].lexeme ;
    } // else
  } // for // --------------------------------------------------------temp print 

  cout << endl << endl ;
  cout << "> " ;
} // PrintSExp()

void TokenTree :: BuildTokenTree( vector<Token> tokenList ) {
  // stack store every return token tree node
  stack<TokenTreeNode> nodeS ;
  TokenTreeNodePtr walk = head ;

  for ( int i = 0 ; i < tokenList.size() ; i++ ) {
    string keyStr = tokenList[i].lexeme ;
    if ( keyStr == "(" ) {
      parentheseCount++ ;

      if ( walk == NULL ) {
        walk = new TokenTreeNode ;
        walk -> internal = true ;
        walk -> left = NULL ;
        walk -> right = NULL ;
        nodeS.push( *walk ) ;
        head = walk ;
      } // if

      else {
        if ( walk -> left == NULL ) {
          walk -> internal = true ;
          walk -> left = new TokenTreeNode ;
          walk = walk -> left ;
          walk -> internal = false ;
          walk -> left = NULL ;
          walk -> right = NULL ;
          nodeS.push( *walk ) ; 
        } // if

        else if ( walk -> right == NULL ) {
          walk -> internal = true ;
          walk -> right = new TokenTreeNode ;
          walk = walk -> right ;
          walk -> internal = false ;
          walk -> left = NULL ;
          walk -> right = NULL ;
          nodeS.push( *walk ) ; 
        } // else if 

        else { // walk -> left && right != NULL 
          TokenTreeNodePtr temp ;
          temp = new TokenTreeNode ;
          temp -> internal = true ;
          temp -> left = walk -> right ;
          temp -> right = NULL ;
          walk -> right = temp ;
          walk = walk -> right ;
          // no need push into stack??
        } // else
      } // else
    } // if

    else if ( keyStr == ")" ) {
      parentheseCount-- ;
      nodeS.pop() ;
      walk = &nodeS.top() ;
    } // else if

    else if ( keyStr == "." ) {
      nodeS.pop() ;
      walk = &nodeS.top() ;
      if ( walk -> right != NULL ) {
        TokenTreeNodePtr temp = new TokenTreeNode ;
        temp -> internal = true ;
        temp -> left = walk -> right ;
        temp -> right = NULL ;
        walk -> right = temp ;
        walk = walk -> right ;
        // no need push into stack??
      } // if
    } // else if

    else {
      if ( walk -> left == NULL ) {
        walk -> left = new TokenTreeNode ;
        walk = walk -> left ;
        walk -> left = NULL ;
        walk -> right = NULL ;
        walk -> internal = false ;
        walk -> token = tokenList[i] ;
        nodeS.push( *walk ) ;
      } // if

      else if ( walk -> right == NULL ) {
        walk -> right = new TokenTreeNode ;
        walk = walk -> right ;
        walk -> left = NULL ;
        walk -> right = NULL ;
        walk -> internal = false ;
        walk -> token = tokenList[i] ;
        nodeS.push( *walk ) ;
      } // else if

      else {
        cout << "unexpected error\n" ;
      } // else

      if ( tokenList[i+1].tokenType == INT || tokenList[i+1].tokenType == FLOAT ||
           tokenList[i+1].tokenType == SYMBOL ) {
        Token tempToken ;
        tempToken.lexeme = "." ;
        tempToken.tokenType = DOT ;
        tokenList.insert( tokenList.begin()+i+1, tempToken ) ;

        tempToken.lexeme = "(" ;
        tempToken.tokenType = LEFT_PAREN ;
        tokenList.insert( tokenList.begin()+i+2, tempToken ) ;

        tempToken.lexeme = "." ;
        tempToken.tokenType = DOT ;
        tokenList.insert( tokenList.begin()+i+4, tempToken ) ;

        tempToken.lexeme = "nil" ;
        tempToken.tokenType = NIL ;
        tokenList.insert( tokenList.begin()+i+5, tempToken ) ;

        tempToken.lexeme = ")" ;
        tempToken.tokenType = RIGHT_PAREN ;
        tokenList.insert( tokenList.begin()+i+6, tempToken ) ;
      } // if 

      else if ( tokenList[i-1].tokenType == LEFT_PAREN && tokenList[i+1].tokenType == RIGHT_PAREN ) {
        Token tempToken ;
        tempToken.lexeme = "." ;
        tempToken.tokenType = DOT ;
        tokenList.insert( tokenList.begin()+i+1, tempToken ) ;

        tempToken.lexeme = "nil" ;
        tempToken.tokenType = NIL ;
        tokenList.insert( tokenList.begin()+i+2, tempToken ) ;
      } // else if
    } // else
  } // for
} // BuildTokenTree()

