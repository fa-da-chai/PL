# include <stdio.h>
# include <string>
# include <iostream>
# include <stdlib.h>
# include <vector>
# include <stack>

using namespace std ;

int gLine = 0 ; 
int gColumn = 0 ;
int gTestNum ;

enum TokenType {
  INT, STRING, DOT, FLOAT, NIL,
  T, QUOTE, SYMBOL, LEFT_PAREN, RIGHT_PAREN 
};

struct Token {
  int tokenType ;
  string lexeme ;   
  // int line ;
  int column ;
} ; 

struct TokenTreeNode {
  Token token ;  
  bool internal ;
  TokenTreeNode *left ;
  TokenTreeNode *right ;
} ; 

typedef TokenTreeNode *TokenTreeNodePtr ; // use to build token tree 

class TokenTree {
  private :
    TokenTreeNodePtr head ;
    int parentheseCount ;
    
  public :
    void BuildTokenTree( vector<Token> tokenList ) ;
    TokenTreeNodePtr GetTokenTree() {
      return head ;
    } // GetTokenTree()

    void Reset() {
      head = NULL ;
      parentheseCount = 0 ;
    } // Reset()

    void SetParenCount( int num ) {
      parentheseCount = num ;
    } // SetParenCount()
} ;

struct ANodeOfLine {
  int line ;
  vector<Token> tokenList ;
  TokenTree tokenTree ;
  ANodeOfLine *next ;
} ;

typedef ANodeOfLine *ANodeOfLinePtr ;

bool ReadSExp( ANodeOfLinePtr &programHead ) ; 
string GetToken( bool &eol ) ; // return false if doesn't get token
bool IsWhiteSpace( char ch ) ;
bool IsSeparator( char ch ) ;
void SkipWhiteSpace() ;
void SkipComment() ;
bool IsExit( vector<Token> tokenList ) ;
int DefToken( string lexeme ) ;
bool IsNum( char ch ) ;
bool IsOperator( char ch ) ; // +,-,*,/
void BuileTree( vector<Token> tokenList ) ;
void HandleBackslash( string &token ) ;
void PrintSExp( ANodeOfLinePtr head ) ;
void PrintTokenTreeRecur( TokenTreeNodePtr head, TokenTreeNodePtr walk, int spaceCount, bool first ) ;
void PrintTokenTree( TokenTreeNodePtr head ) ;
void PreOrder( TokenTreeNodePtr head ) {
  if ( head == NULL ) {
    //cout << "NULL\n" ;
  } // if

  else {
    if ( head -> internal ) 
      cout << "internal\n" ;
    else
      cout << head -> token.lexeme << endl ;

    //cout << "left:" ;
    PreOrder( head -> left ) ;
    //cout << "right:" ;
    PreOrder( head -> right ) ;
  } // else
} // PreOrder()

int main() {
  bool haveExit = false ;
  ANodeOfLinePtr programHead = NULL ;
  scanf( "%d", &gTestNum ) ;
  cout << "Welcome to OurScheme!" ;
  cout << "\n\n" ;
  cout << "> " ;
  haveExit = ReadSExp( programHead ) ;
  if ( haveExit ) {
    cout << endl << "Thanks for using OurScheme!" ;
  } // if

  else {
    cout << "END-OF-LINE\n" ;// error END-OF-FILE encountered
  } // else
  /*
  repeat
  
    ReadSExp(expr);
    
    PrintSExp(expr); // You must "pretty print" this data structure.
      
    Print '> '
    
  until (OR (user entered '(exit)')
            (END-OF-FILE encountered)
        )
  
  if ( END-OF-FILE encountered ) // and NOT ?user entered '(exit)'?
    Print 'ERROR (no more input) : END-OF-FILE encountered' 

  Print '\n'
  Print 'Thanks for using OurScheme!' // Doesn't matter whether there is an
                                      // '\n' at the end
  */
} // main()

bool ReadSExp( ANodeOfLinePtr &programHead ) { // if there has a white space in the end of input,program will see it as the same line 
  Token token ;                                // fix it in function GetToken -> SkipWhiteSpace 
  ANodeOfLinePtr walk = programHead ;
  bool eol = false ; // END_OF_LINE
  bool exit = false ; 
  bool sExpEnd = false ;
  int parenCount = 0 ;

  token.lexeme = GetToken( eol ) ;
  while ( cin.peek() != EOF && !exit ) {
    token.tokenType = DefToken( token.lexeme ) ;
    if ( programHead == NULL ) {
      programHead = new ANodeOfLine ;
      programHead -> next = NULL ;
      walk = programHead ;
    } // if

    walk -> tokenList.push_back( token ) ;
    if ( walk -> tokenList[0].lexeme != "(" && walk -> tokenList[0].lexeme != "\'" ) {
      sExpEnd = true ;
    } // if

    else {
      eol = true ;
      if ( token.lexeme == "(" )
        parenCount++ ;

      else if ( token.lexeme == ")" ) {
        parenCount-- ;
      } // else if

      if ( parenCount == 0 && token.lexeme != "\'" )
        sExpEnd = true ;
    } // else
 
    if ( eol && sExpEnd )  {
      exit = IsExit( walk -> tokenList ) ;
      // assign line to a node of line
      if ( !exit ) {
        if ( walk -> tokenList[0].lexeme == "(" || walk -> tokenList[0].lexeme == "\'" ) {
          walk -> tokenTree.BuildTokenTree( walk -> tokenList ) ;
        } // if

        PrintSExp( walk ) ;
        walk -> next = new ANodeOfLine ;
        walk = walk -> next ;
        walk -> next = NULL ;
        walk -> tokenTree.Reset() ;
        eol = false ;
        sExpEnd = false ;
        parenCount = 0 ;
      } // if
    } // if

    if ( !exit )
      token.lexeme = GetToken( eol ) ;
  } // while

  return exit ;
} // ReadSExp()

string GetToken( bool &eol ) {
  char ch ;
  string token = "" ;
  bool firstIsSprt = true ;
  eol = false ;
  SkipWhiteSpace() ;
  while ( cin.peek() != EOF && !IsSeparator( cin.peek() ) ) {
    scanf( "%c", &ch ) ;
    if ( ch == ';' ) { // skip comment ;
      SkipComment() ;
      if ( token == "" ) 
        SkipWhiteSpace() ;
    } // if

    else {
      token += ch ;
      firstIsSprt = false ;
    }  // else
  } // while

  if ( firstIsSprt ) { // (, ), ', ", ;
    scanf( "%c", &ch ) ;
    if ( ch == '(' && cin.peek() == ')' ) { // () == nil, may have ( )
      scanf( "%c", &ch ) ;
      token = "nil" ;
    } // else if

    else if ( ch == '"' ) { // string
      token += ch ;
      bool endStr = false, findDoubleQuote = false ;
      while ( !endStr ) { // get string
        scanf( "%c", &ch ) ;
        if ( ch == '\"' ) {
          token += ch ;
          findDoubleQuote = true ;
          endStr = true ;
        } // if
        
        else if ( ch == '\n' ) {
          endStr = true ;
          // error:not have double quote
        } // else if

        else if ( ch == '\\' ) {
          HandleBackslash( token ) ;
        } // else if

        else {
          token += ch ;
        } // else 
      } // while

      eol = true ;
    } // else if

    else {
      token += ch ;
    } // else
  } // if

  if ( cin.peek() == '\n' ) {
    eol = true ;
  } // if

  if ( token == "t" ) {
    token = "#t" ;
  } // if
  
  else if ( token == "#f" ) { // nil, #f
    token = "nil" ;
  } // else if

  return token ;
} // GetToken()

bool IsWhiteSpace( char ch ) { // ' ', '\n', '\t', end of file
  if ( ch == ' ' )
    return true ;
  else if ( ch == '\n' )
    return true ;
  else if ( ch == '\t' )
    return true ;
  else 
    return false ; 
} // IsWhiteSpace()

bool IsSeparator( char ch ) { // white space, '(', ')', '\'', '\"', !!'; is seperator but return false here'
  if ( IsWhiteSpace( ch ) )
    return true ;
  else if ( ch == '(' )
    return true ;
  else if ( ch == ')' )
    return true ;
  else if ( ch == '\'' )
    return true ;
  else if ( ch == '\"' )
    return true ;
  /*else if ( ch == ';' )
    return true ;*/ 
  else 
    return false ;
} // IsSeparator()

void SkipWhiteSpace() {
  while ( cin.peek() != EOF && IsWhiteSpace( cin.peek() ) ) {
    char ch ;
    scanf( "%c", &ch ) ;
    if ( ch == '\n' )
      gLine++ ;
  } // while
} // SkipWhiteSpace()

void SkipComment() {
  char cStr[256] ;
  cin.get( cStr, 256, '\n' ) ;
} // SkipComment() 

bool IsExit( vector<Token> tokenList ) {
  if ( tokenList[0].lexeme == "(" ) {
    if ( tokenList[1].lexeme == "exit" ) {
      if ( tokenList[2].lexeme == ")" ) {
        return true ;
      } // if
    } // if
  } // if

  return false ;
} // IsExit()

int DefToken( string lexeme ) {
  if ( lexeme == "(" ) {
    return LEFT_PAREN ;
  } // if

  else if ( lexeme == ")" ) {
    return RIGHT_PAREN ;
  } // else if

  else if ( lexeme == "." ) {
    return DOT ;
  } // else if

  else if ( lexeme[0] == '"' ) {
    return STRING ;
  } // else if

  else if ( lexeme == "nil" || lexeme == "#f" ) {
    return NIL ;
  } // else if

  else if ( lexeme == "t" || lexeme == "#t" ) {
    return T ;
  } // else if

  else if ( lexeme == "'" || lexeme == "\"" ) {
    return QUOTE ;
  } // else if

  else if ( IsNum( lexeme[0] ) || IsOperator( lexeme[0] ) || lexeme[0] == '.' ) { // int or float
    bool isFloat = false, haveADot = false ;
    bool isSymbol = false ;
    for ( int i = 0 ; i < lexeme.size() ; i++ ) {
      if ( lexeme[i] == '.' && !haveADot ) {
        isFloat = true ;
        haveADot = true ;
      } // if

      else if ( !IsNum( lexeme[i] ) ) {
        isSymbol = true ;
      } // else if
    } // for

    if ( isSymbol )
      return SYMBOL ;
    else if ( isFloat )
      return FLOAT ;
    else 
      return INT ;
    // may have error 
  } // else if

  else { // symbol
    return SYMBOL ;
    // maybe have error 
  } // else 
} // DefToken()

bool IsNum( char ch ) {
  if ( ch >= '0' && ch <= '9' )
    return true ;

  return false ;
} // IsNum()

bool IsOperator( char ch ) { // +,-,*,/
  if ( ch == '+' ) 
    return true ;

  else if ( ch == '-' )
    return true ;

  else if ( ch == '*' )
    return true ;

  else if ( ch == '/' )
    return true ;

  else 
    return false ;
} // IsOperator()

void HandleBackslash( string &token ) {
  char ch = '\\' ;
  if ( cin.peek() == '\"' ) {
    scanf( "%c", &ch ) ;
    token += ch ;
  } // if

  else if ( cin.peek() == '\\' ) {
    scanf( "%c", &ch ) ;
    token += ch ;
  } // else if
 
  else if ( cin.peek() == 'n' ) {
    scanf( "%c", &ch ) ;
    token += '\n' ;   
  } // else if

  else if ( cin.peek() == 't' ) {
    scanf( "%c", &ch ) ;
    token += '\t' ;
  } // else if

  else {
    token += ch ;
  } // else
} // HandleBackslash()

void PrintSExp( ANodeOfLinePtr head ) {
  TokenTreeNodePtr tokenTreeHead = head -> tokenTree.GetTokenTree() ;
  if ( tokenTreeHead != NULL ) {
    /*for ( int i = 0 ; i < head -> tokenList.size() ;i ++ ) {
      cout << head -> tokenList[i].lexeme << endl ;
    } // for
    cout << endl ;*/
    // PreOrder( tokenTreeHead ) ;
    PrintTokenTree( tokenTreeHead ) ;
  } // if

  else {
    for ( int i = 0 ; i < head -> tokenList.size() ; i++ ) {
      if ( head -> tokenList[i].tokenType == INT ) { // handle +123, +12.3, -5.6363
        int tempInt = stoi( head -> tokenList[i].lexeme ) ;
        cout << tempInt ;
      } // if

      else if ( head -> tokenList[i].tokenType == FLOAT ) { // +123.5,-5.6363,-9.2
        float tempFloat = stof( head -> tokenList[i].lexeme ) ; 
        printf( "%.3f", tempFloat ) ;
      } // else if

      else {
        cout << head -> tokenList[i].lexeme ;
      } // else
    } // for // --------------------------------------------------------temp print 
  } // else

  cout << endl << endl ;
  cout << "> " ;
} // PrintSExp()

void TokenTree :: BuildTokenTree( vector<Token> tokenList ) {
  // stack store every return token tree node
  stack<TokenTreeNodePtr> nodeS ;
  TokenTreeNodePtr walk = head ;
  int i = 0 ;
  if ( tokenList[0].lexeme == "\'" ) {
    head = new TokenTreeNode ;
    head -> right = NULL ;
    head -> left = new TokenTreeNode ;
    head -> internal = true ;

    nodeS.push( head ) ;

    head -> left -> left = NULL ;
    head -> left -> right = NULL ;
    head -> left -> internal = false ;
    head -> left -> token = tokenList[0] ;
    head -> left -> token.lexeme = "quote" ;
    walk = head -> left ;
    nodeS.push( walk ) ;
    i++ ;
  } // if

  for ( ; i < tokenList.size() ; i++ ) {
    string keyStr = tokenList[i].lexeme ;
    if ( keyStr == "(" ) {
      parentheseCount++ ;

      if ( walk == NULL ) {
        walk = new TokenTreeNode ;
        walk -> internal = true ;
        walk -> left = NULL ;
        walk -> right = NULL ;
        nodeS.push( walk ) ;
        head = walk ;
      } // if

      else if ( !walk -> internal ) {
        nodeS.pop() ;
        walk = nodeS.top() ;
        if ( walk -> right != NULL )
          cout << "unexpected error:line 489\n" ;

        else {
          Token tempToken ;
          tempToken.lexeme = "nil" ;
          tempToken.tokenType = NIL ;

          walk -> right = new TokenTreeNode ;
          walk = walk -> right ;
          walk -> internal = true ;
          walk -> left = new TokenTreeNode ;
          walk -> right = new TokenTreeNode ; // put nil in the node

          walk -> right -> left = NULL ; // put nil in the node
          walk -> right -> right = NULL ; // put nil in the node
          walk -> right -> token = tempToken ; // put nil in the node
          walk -> right -> internal = false ; // put nil in the node
 
          walk = walk -> left ;
          walk -> internal = true ;
          walk -> left = NULL ;
          walk -> right = NULL ;
          nodeS.push( walk ) ;
        } // else
      } // else if

      else {
        if ( walk -> left == NULL ) {
          walk -> left = new TokenTreeNode ;
          walk = walk -> left ;
          walk -> internal = true ;
          walk -> left = NULL ;
          walk -> right = NULL ;
          nodeS.push( walk ) ; 
        } // if

        else if ( walk -> right == NULL ) {
          walk -> right = new TokenTreeNode ;
          walk = walk -> right ;
          walk -> internal = true ;
          walk -> left = NULL ;
          walk -> right = NULL ;
          nodeS.push( walk ) ; 
        } // else if 

        else { // walk -> left != NULL && right != NULL 
          TokenTreeNodePtr temp ;
          temp = new TokenTreeNode ;
          temp -> internal = true ;
          temp -> left = walk -> right ;
          temp -> right = NULL ;
          walk -> right = temp ;
          walk = walk -> right ;
          // no need push into stack??
        } // else
      } // else
    } // if

    else if ( keyStr == ")" ) {
      if ( tokenList[i-1].lexeme == "(" ) {
        cout << "unexpected error:line 519\n" ;
      } // if

      parentheseCount-- ;
      nodeS.pop() ;
      walk = nodeS.top() ;
      if ( walk ->  right == NULL ) {
        Token tempToken ;
        tempToken.lexeme = "nil" ;
        tempToken.tokenType = NIL ;
        walk -> right = new TokenTreeNode ;
        walk -> right -> left = NULL ;
        walk -> right -> right = NULL ;
        walk -> right -> token = tempToken ;
        walk -> right -> internal = false ;
      } // if
    } // else if

    else if ( keyStr == "." ) {
      nodeS.pop() ;
      walk = nodeS.top() ;
      if ( walk -> right != NULL ) {
        TokenTreeNodePtr temp = new TokenTreeNode ;
        temp -> internal = true ;
        temp -> left = walk -> right ;
        temp -> right = NULL ;
        walk -> right = temp ;
        walk = walk -> right ;
        // no need push into stack??
      } // if
    } // else if

    else {
      if ( !walk -> internal ) { // may have a problem
        nodeS.pop() ;
        walk = nodeS.top() ;
        if ( walk -> right != NULL ) {
          cout << "unexpected error:line603\n" ;
          exit(0) ;
        } // if

        else {
          walk -> right = new TokenTreeNode ;
          walk = walk -> right ;
          walk -> internal = true ;
          walk -> left = new TokenTreeNode ;

          // if ( tokenList[i+1].tokenType == INT || tokenList[i+1].tokenType == FLOAT ||
          //      tokenList[i+1].tokenType == SYMBOL || tokenList[i+1].tokenType == NIL || tokenList[i+1].tokenType == DOT ) {
          if ( tokenList[i+1].tokenType == RIGHT_PAREN ) {
            Token tempToken ;
            tempToken.lexeme = "nil" ;
            tempToken.tokenType = NIL ;
            walk -> right = new TokenTreeNode ;
            walk -> right -> left = NULL ;
            walk -> right -> right = NULL ;
            walk -> right -> token = tempToken ;
            walk -> right -> internal = false ;
          } // if

          else {
            nodeS.pop() ;
            nodeS.push( walk ) ;
            walk -> right = NULL ;
          } // else

          walk = walk -> left ;
          walk -> left = NULL ;
          walk -> right = NULL ;
          walk -> internal = false ;
          walk -> token = tokenList[i] ;
          nodeS.push( walk ) ;
        } // else
      } // if

      else if ( walk -> left == NULL ) {
        walk -> left = new TokenTreeNode ;
        walk = walk -> left ;
        walk -> left = NULL ;
        walk -> right = NULL ;
        walk -> internal = false ;
        walk -> token = tokenList[i] ;
        nodeS.push( walk ) ;
      } // if

      else if ( walk -> right == NULL ) {
        walk -> right = new TokenTreeNode ;
        walk = walk -> right ;
        walk -> left = NULL ;
        walk -> right = NULL ;
        walk -> internal = false ;
        walk -> token = tokenList[i] ;
        nodeS.push( walk ) ;
      } // else if

      else {
        cout << "unexpected error:line616\n" ;
      } // else
    } // else
  } // for
} // BuildTokenTree()

void PrintTokenTree( TokenTreeNodePtr head ) {
  // cout << "( " ;
  int spaceCount = 1 ;
  PrintTokenTreeRecur( head, head, spaceCount, true ) ;
  // if ( !( head -> right -> internal ) ) {
  //   cout << "   .\n" ;
  // } // if

  // PrintTokenTreeRecur( head, head -> right, spaceCount, false ) ;
} // PrintTokenTree()

void PrintTokenTreeRecur( TokenTreeNodePtr head, TokenTreeNodePtr walk, int spaceCount, bool first ) { 
  if ( walk == head ) {
    bool firstBrace = false ;
    cout << "( " ;
    if ( head -> left -> internal ) {
      cout << "( " ;
      firstBrace = true ;
    } // if

    PrintTokenTreeRecur( head, head -> left, spaceCount+1, true ) ;
    if ( firstBrace ) {
      cout << "  )\n" ; 
    } // if 

    if ( walk -> right -> internal ) {
      if ( !( head -> right -> internal ) ) {
        cout << "  .\n" ;
      } // if

      PrintTokenTreeRecur( head, head -> right, spaceCount, false ) ;
    } // if

    else {
      if ( walk -> right -> token.tokenType != NIL )
        PrintTokenTreeRecur( head, head -> right, spaceCount, false ) ;
    } // else

    cout << ")" ;
  } // if

  else if ( walk == NULL ) {
    ;
  } // else if

  else {
    // if is internal node
    //   if ( now -> left == internal )
    //     recursive left,spaceCount+1
    //     recursive right,spaceCount+1
    //   else
    //     recursive left,spaceCount
    //     recursive right,spaceCount
    //   return 

    // else 
    //   if is right is nil
    //     cout << sapce << right_paren
    //   else
    //     cout << space << token
    if ( walk -> internal ) {
      if ( walk -> left -> internal ) {
        if ( !first ) {
          for ( int i = 0 ; i < spaceCount ; i++ )
            cout << "  " ;
        } // if

        cout << "( " ;
        PrintTokenTreeRecur( head, walk -> left, spaceCount+1, true ) ;

        for ( int i = 0 ; i < spaceCount ; i++ ) {
          cout << "  " ;
        } // for 

        cout << ")\n" ;

        if ( !walk -> right -> internal ) {
          if ( walk -> right -> token.tokenType != NIL ) {
            PrintTokenTreeRecur( head, walk -> right, spaceCount, false ) ;
          } // if
        } // if
 
        else {
          PrintTokenTreeRecur( head, walk -> right, spaceCount, false ) ;
        } // else
      } // if

      else {
        PrintTokenTreeRecur( head, walk -> left, spaceCount, first ) ;

        if ( walk -> right -> internal ) {
          PrintTokenTreeRecur( head, walk -> right, spaceCount, false ) ;
        } // if

        else {
          if ( walk -> right -> token.tokenType != NIL ) {
            for ( int i = 0 ; i < spaceCount ; i++ ) {
              cout << "  " ;
            } // for 

            cout << ".\n" ;
            PrintTokenTreeRecur( head, walk -> right, spaceCount, false ) ;
          } // if 
        } // else
      } // else
    } // if

    else {
      if ( !first ) {
        for ( int i = 0 ; i < spaceCount ; i++ ) {
          cout << "  " ;
        } // for 
      } // if

      if ( walk -> token.tokenType == INT ) { // handle +123, +12.3, -5.6363
        int tempInt = stoi( walk -> token.lexeme ) ;
        cout << tempInt << endl ; 
      } // if

      else if ( walk -> token.tokenType == FLOAT ) { // +123.5,-5.6363,-9.2
        float tempFloat = stof( walk -> token.lexeme ) ; 
        printf( "%.3f\n", tempFloat ) ;
      } // else if

      else {
        cout << walk -> token.lexeme << endl ;
      } // else
    } // else 
  } // else
} // PrintTokenTrtreeRecur()

