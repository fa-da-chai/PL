# include <stdio.h>
# include <string>
# include <iostream>
# include <stdlib.h>
# include <vector>

using namespace std ;

int gLine = 0 ; 
int gColumn = 0 ;
int gTestNum ;

enum TokenType {
  INT, STRING, DOT, FLOAT, NIL,
  T, QUOTE, SYMBOL, LEFT_PAREN, RIGHT_PAREN 
};

struct Token {
  int tokenType ;
  string lexeme ;   
  // int line ;
  int column ;
} ; 

struct ANodeOfLine {
  int line ;
  vector<Token> tokenList ;
  ANodeOfLine *next ;
} ;

typedef ANodeOfLine *ANodeOfLinePtr ;

void ReadSExp( ANodeOfLinePtr &programHead ) ; 
string GetToken( bool &eol ) ; // return false if doesn't get token
bool IsWhiteSpace( char ch ) ;
bool IsSeparator( char ch ) ;
void SkipWhiteSpace() ;
void SkipComment() ;

int main() {
  ANodeOfLinePtr programHead ;
  scanf( "%d", &gTestNum ) ;
  cout << "Welcome to OurScheme!" ;
  cout << "\n" ;
  cout << "> " ;
  ReadSExp( programHead ) ;
  /*
  repeat
  
    ReadSExp(expr);
    
    PrintSExp(expr); // You must "pretty print" this data structure.
      
    Print '> '
    
  until (OR (user entered '(exit)')
            (END-OF-FILE encountered)
        )
  
  if ( END-OF-FILE encountered ) // and NOT ?user entered '(exit)'?
    Print 'ERROR (no more input) : END-OF-FILE encountered' 

  Print '\n'
  Print 'Thanks for using OurScheme!' // Doesn't matter whether there is an
                                      // '\n' at the end
  */
} // main()

void ReadSExp( ANodeOfLinePtr &programHead ) {
  Token token ;
  programHead = new ANodeOfLine ;
  ANodeOfLinePtr walk = programHead ;
  programHead -> next = NULL ;
  bool eol = false ; // END_OF_LINE

  token.lexeme = GetToken( eol ) ;
  while ( cin.peek() != EOF && token.lexeme != "exit" ) {
    walk -> tokenList.push_back( token ) ;
    if ( eol )  {
      // assign line to a node of line
      for ( int i = 0 ; i < walk -> tokenList.size() ; i++ ) {
        cout << walk -> tokenList[i].lexeme ;
      } // for
  
      cout << endl ;
      cout << "> " ;
      walk -> next = new ANodeOfLine ;
      walk = walk -> next ;
      walk -> next = NULL ;
      eol = false ;
    } // if

    token.lexeme = GetToken( eol ) ;
    // judge the token type
    // put token into tokenlist
    // with the way to build tree(pretty print)
  } // while
} // ReadSExp()

string GetToken( bool &eol ) {
  char ch ;
  string token = "" ;
  bool firstIsSprt = true ;
  eol = false ;
  SkipWhiteSpace() ;
  while ( cin.peek() != EOF && !IsSeparator( cin.peek() ) ) {
    scanf( "%c", &ch ) ;
    if ( ch == ';' ) { // skip comment ;
      SkipComment() ;
    } // if

    token += ch ;
    firstIsSprt = false ;
  } // while

  if ( firstIsSprt ) {
    scanf( "%c", &ch ) ;
    token += ch ;
  } // if

  if ( cin.peek() == '\n' ) {
    eol = true ;
  } // if

  return token ;
} // GetToken()

bool IsWhiteSpace( char ch ) { // ' ', '\n', '\t', end of file
  if ( ch == ' ' )
    return true ;
  else if ( ch == '\n' )
    return true ;
  else if ( ch == '\t' )
    return true ;
  else 
    return false ; 
} // IsWhiteSpace()

bool IsSeparator( char ch ) { // white space, '(', ')', '\'', '\"', ';'
  if ( IsWhiteSpace( ch ) )
    return true ;
  else if ( ch == '(' )
    return true ;
  else if ( ch == ')' )
    return true ;
  else if ( ch == '\'' )
    return true ;
  else if ( ch == '\"' )
    return true ;
  else if ( ch == ';' )
    return true ;
  else 
    return false ;
} // IsSeparator()

void SkipWhiteSpace() {
  while ( cin.peek() != EOF && IsWhiteSpace( cin.peek() ) ) {
    char ch ;
    scanf( "%c", &ch ) ;
    if ( ch == '\n' )
      gLine++ ;
  } // while
} // SkipWhiteSpace()

void SkipComment() {
  char cStr[256] ;
  if ( !cin.get( cStr, 256, '\n' ) )
    cout << "errorï¼šlast  line is comment\n" ;
} // SkipComment


